---
title: ""
emoji: "💬"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

---
# C言語の文字列――リテラル／配列／ポインタの違いとメモリ配置

C言語の文字列には大きく分けて以下の3種類があります。
それぞれメモリ上の配置や取り扱いが異なるため、挙動の違いを理解しておきましょう。

1. **文字列リテラル（文字列定数）**
2. **文字配列**
3. **文字列ポインタ**

---

## 1. 文字列リテラル（文字列定数）

```c
char *s = "Hello, World!";
```

* **定数（`const`相当）**
* プログラム実行中は変更不可
* コンパイラが用意する「静的領域（.rodataなど）」に配置
* 複数回同じリテラルが出現すると、１つの領域を共有することがある

---

## 2. 文字配列

```c
char s[] = "Hello, World!";
```

* 実際には文字数＋終端文字分の要素を持つ配列
* 変数と同様、**スタック領域**（関数内宣言の場合）や**データ領域**（静的・グローバルの場合）に配置
* 要素を書き換え可能
* サイズは初期化時にしか決まらない

---

## 3. 文字列ポインタ

```c
const char *p = /* 何らかの文字列 */ ;
```

* ポインタ変数（アドレスを保持）
* ポインタ自体はスタック上に配置され、中身はどこかの文字列領域を指す
* 指している先が文字列リテラルなのか、ヒープや配列なのかはコード次第
* 書き換え可能な領域を指していなければ、参照先の書き換えは未定義動作

---

### 参考リンク

* 文字列ポインタとリテラルの解説
  [https://www.kushiro-ct.ac.jp/yanagawa/C-2017/15-0613/index.html#strptr](https://www.kushiro-ct.ac.jp/yanagawa/C-2017/15-0613/index.html#strptr)
* メモリレイアウトと文字列の扱い
  [https://www.kushiro-ct.ac.jp/yanagawa/C-2017/24-0712/index.html](https://www.kushiro-ct.ac.jp/yanagawa/C-2017/24-0712/index.html)

---

# プロトタイプ宣言（関数宣言）のポイント

* 関数には通常、**プロトタイプ宣言**（返り値と仮引数の型を宣言）を行う
* プロトタイプがあれば、コンパイラは型チェックを行い、呼び出しミスを検出できる
* 仮引数の**名前**は一致しなくてもよいが、**ドキュメントとして合わせておく**と可読性UP

```c
/* header.h */
int  compute(int a, int b);

/* source.c */
#include "header.h"

int compute(int x, int y) {
    return x + y;
}
```

---

# ヘッダファイルの仕組み

* ヘッダ（`.h`）に**プロトタイプ宣言**や**構造体定義**、**マクロ定義**などを記述
* ソース（`.c`）側で`#include "header.h"`すると、プリプロセス時に展開される
* **一貫した宣言**と**再利用性向上**のために、共通定義はヘッダにまとめる

---

# `static`変数の格納先

* **関数内の`static`変数**もグローバル変数と同様、**静的領域**（データセグメント）に配置
* プログラム起動から終了までメモリが確保され続ける
* `static`の有効範囲は宣言されたスコープ内に限定される

```c
void foo(void) {
    static int counter = 0;
    counter++;
    printf("%d\n", counter);
}
```

---

## まとめ

* **文字列リテラル**は定数、**文字配列**は可変、**ポインタ**は間接的に参照
* メモリ配置を意識して、安全かつ効率的なコードを書く
* ヘッダファイルとプロトタイプ宣言で型チェックを徹底
* `static`変数は永続的にメモリを確保するので、必要な場面で適切に利用

苦手意識のあるC言語の文字列周りも、メモリモデルを意識するとグッと理解が深まります。ぜひ試してみてください！
